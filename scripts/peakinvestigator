#!/usr/bin/env python3

import sys, os
import os.path
import posixpath
import sqlite3
import math

import numpy

from peakinvestigator import *
from peakinvestigator.actions import *

class PeakInvestigator(object):
	VERSION = "4.2"
	MODES = ["submit", "list", "fetch", "fetch_all", "delete"]

	def __init__(self, args):
		self._args = args
		
		
		mode_args = [ getattr(args, x) for x in self.MODES ]
		
		self._modes = [ x for x, y in zip(self.MODES, mode_args) if y is True ]
		self._username = os.environ["USERNAME"]
		self._password = os.environ["PASSWORD"]
		self._project = os.environ["PROJECT"]
	
	def run(self):
		if len(self._modes) != 1:
			print("ERROR: Invalid number of modes specified.", file=sys.stderr)
			sys.exit(-1)
			
		print("Running", self._modes[0])
		if self._modes[0] == "submit":
			[ self._submit(x) for x in self._args.files ]
		if self._modes[0] == "fetch_all":
			db = self._open_database(self._args.database)
			[ self._fetch(x[0]) for x in self._get_jobs_from_db(db) ]
			[ self._delete(x[0]) for x in self._get_jobs_from_db(db) ]
		if self._modes[0] == "fetch":
			[ self._fetch(x) for x in self._args.files ]
		if self._modes[0] == "delete":
			[ self._delete(x) for x in self._args.files ]

	def _submit(self, filename):
		data = numpy.loadtxt(filename)
		min_mass = math.floor(data[0, 0])
		max_mass = math.ceil(data[-1, 0])
		lines = len(data)
		
		service = PeakInvestigatorSaaS()
		versions_action = PiVersionsAction(self.VERSION, self._username,
											self._password)
		response = service.execute(versions_action)
		versions_action.process_response(response)
		
		init_action = InitAction(self.VERSION, self._username, self._password,
								self._project, versions_action.current_version)
		init_action.with_scan_count(1, 0).with_meta_data(min_mass, max_mass, lines)
		
		response = service.execute(init_action)
		init_action.process_response(response)
		
		if type(init_action.error) is str:
			print("ERROR: {error}.".format(error=init_action.error), file=sys.stderr)
			sys.exit(-2)
		
		if init_action.funds < max([ x["Cost"] for x in init_action.estimated_costs ]):
			print("ERROR: insufficient funds.", file=sys.stderr)
			sys.exit(-2);

		rto = sorted(init_action.response_time_objectives)[0]
		
		sftp_action = SftpAction(self.VERSION, self._username, self._password,
									self._project)
		response = service.execute(sftp_action)
		sftp_action.process_response(response)
		service.upload(sftp_action, filename,
						posixpath.join(sftp_action.directory, os.path.split(filename)[-1]))
		
		run_action = RunAction(self.VERSION, self._username, self._password,
								init_action.job, rto).with_files(filename)
								
		response = service.execute(run_action)
		run_action.process_response(response)
		
		if type(run_action.error) is str:
			print("ERROR: {error}.".format(error=run_action.error), file=sys.stderr)
			sys.exit(-2)
		
		print("Running job: ", run_action.job)

		db = self._open_database(self._args.database)
		self._save_into_db(db, run_action.job, filename)
	
	def _fetch(self, job):
		service = PeakInvestigatorSaaS()
		status = StatusAction(self.VERSION, self._username, self._password, job)
		
		response = service.execute(status)
		status.process_response(response)
		
		if not status.done:
			print("INFO: Job {job} is not done.".format(job=job))
			return
			
		print("INFO: Fetching results for job {}.".format(job))

		sftp = SftpAction(self.VERSION, self._username, self._password,
							self._project)
		response = service.execute(sftp)
		sftp.process_response(response)

		service.download(sftp, status.results_file,
							posixpath.split(status.results_file)[-1])
		service.download(sftp, status.log_file,
							posixpath.split(status.log_file)[-1])
		
	def _delete(self, job):
		service = PeakInvestigatorSaaS()
		delete = DeleteAction(self.VERSION, self._username, self._password, job)
		
		response = service.execute(delete)
		delete.process_response(response)
		
		if delete.error is not None:
			print("ERROR: {}".format(delete.error), file=sys.stderr)
			return
		
		print("INFO: Deleted job {}.".format(job))
			
		db = self._open_database(self._args.database)
		self._delete_from_db(db, job)

		
	def _open_database(self, filename):
		 db = sqlite3.connect(filename)
		 cursor = db.cursor()
		 
		 cursor.execute("""CREATE TABLE IF NOT EXISTS Jobs
		 					( JobID TEXT UNIQUE NOT NULL, 
		 					Production TEXT NOT NULL, 
		 					Calibration TEXT DEFAULT NULL)""")
		 db.commit()
		 
		 return db
	
	def _save_into_db(self, db, job, filename):
		cursor = db.cursor()
		cursor.execute("""INSERT INTO Jobs (JobID, Production) VALUES
							(?, ?)""", (job, filename))
		db.commit()

	def _get_jobs_from_db(self, db):
		cursor = db.cursor()
		cursor.execute("""SELECT JobID FROM Jobs""")
		return cursor.fetchall()

	def _delete_from_db(self, db, job):
		cursor = db.cursor()
		cursor.execute("""DELETE FROM Jobs WHERE JobID = ?""", (job,))
		db.commit()

		
if __name__ == "__main__":
	from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
	from os.path import expanduser

	parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
	parser.add_argument("-s", "--submit", action="store_true",
							help="Submit one or more files for processing.")
	parser.add_argument("-l", "--list", action="store_true",
							help="List jobs saved to database.")
	parser.add_argument("-f", "--fetch", action="store_true",
							help="Fetch results for one or more jobs.")
	parser.add_argument("-fa", "--fetch-all", action="store_true",
							help="""Fetch all available results in database. 
									Jobs are deleted from server and database.""")
	parser.add_argument("-d", "--delete", action="store_true",
							help="Delete one or more jobs.")
	parser.add_argument("-db", "--database",
							help="File to record job information",
							default=expanduser("~/.peakinvestigator.db"))
	parser.add_argument("files", nargs="*",
							help="Files to submit or jobs to fetch.")
	
	args = parser.parse_args()

	app = PeakInvestigator(args)
	app.run()
	
	
 